plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
N
1:N*N
seq_along(1:N*N)
nn <- N*N
seq_along(1:n)
seq_along(1:nn)
for (i in seq_along(1:nn)) {
grilla <- small_world_reconnect(g = grilla, p=0.8, vtx = i)
}
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
hist(degree(grilla))
small_world_reconnect <- function(g, p, vtx, ord = 1) {
# # # # # Get all neighborhoods of a node in a vector
# Ojo que el primer valor es el mismo nodo i.
ady <- as.numeric(unlist(ego(grilla, order = ord, vtx)))
# ady <- ady[-1]
#adjacent_vertices(grilla, 12 )
# # # # # Get all neighborhoods of a node in a vector
# select the k nodes to be sampled except ady
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
# start
for (i in 1:num) {
j <- i + 1
u <- runif(1)
if ( u <= p) {
# add the edge
g <- add_edges(g, c(ady[1], knodes[i] ) )
# remove the old edge
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
#E(grilla)[ei]
g <- delete_edges(g, ei)
}
}
return(g)
}
# # # # # Create the grille
N = 10 #total number of nodes (humanoids) of the grid-net
grilla <- make_lattice(length = N, dim = 2)
V(grilla)$name <- seq(from =1, to=N*N)
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_reconnect(g = grilla, p=0.2, vtx = i, ord = 1)
}
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
hist(degree(grilla))
l <- layout_on_grid(grilla)
l
as.numeric(unlist(ego(grilla, order = 2, 91)))
as.numeric(unlist(ego(grilla, order = 1, 91)))
ady1 <- as.numeric(unlist(ego(grilla, order = 1, 91)))
ady2 <- as.numeric(unlist(ego(grilla, order = 2, 91)))
setdiff(ady2, ady1)
small_world_reconnect <- function(g, p, vtx, ord = 1) {
# # # # # Get all neighborhoods of a node in a vector
# Ojo que el primer valor es el mismo nodo i.
if (ord == 2) {
ady1 <- as.numeric(unlist(ego(grilla, order = 1, vtx)))
ady2 <- as.numeric(unlist(ego(grilla, order = 2, vtx)))
ady <- setdiff(ady2, ady1)
} else {
ady <- as.numeric(unlist(ego(grilla, order = ord, vtx)))
}
# ady <- ady[-1]
#adjacent_vertices(grilla, 12 )
# # # # # Get all neighborhoods of a node in a vector
# select the k nodes to be sampled except ady
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
# start
for (i in 1:num) {
j <- i + 1
u <- runif(1)
if ( u <= p) {
# add the edge
g <- add_edges(g, c(ady[1], knodes[i] ) )
# remove the old edge
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
#E(grilla)[ei]
g <- delete_edges(g, ei)
}
}
return(g)
}
for (i in seq_along(1:nn)) {
grilla <- small_world_reconnect(g = grilla, p=0.2, vtx = i, ord = 2)
}
i
vtx=i
g = grilla
ady1 <- as.numeric(unlist(ego(grilla, order = 1, vtx)))
ady2 <- as.numeric(unlist(ego(grilla, order = 2, vtx)))
ady <- setdiff(ady2, ady1)
ady
ady
ady1
ady
ady2
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
knodes
i
c(setdiff(ady2, ady1), ady[1])
ady1
ady1[1]
c(setdiff(ady2, ady1), ady1[1])
c(ady1[1], setdiff(ady2, ady1))
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
knodes
ady[1]
ady <- c(ady1[1], setdiff(ady2, ady1))
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
knodes
ady[1]
for (i in 1:num) {
j <- i + 1
u <- runif(1)
if ( u <= p) {
# add the edge
g <- add_edges(g, c(ady[1], knodes[i] ) )
# remove the old edge
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
#E(grilla)[ei]
g <- delete_edges(g, ei)
}
}
i
j
u
u <= p
p
c(ady[1], knodes[i] )
g <- add_edges(g, c(ady[1], knodes[i] ) )
c(ady[1], ady[j])
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
ei
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
coord_cartesian()
coor
coord <- layout_on_grid(grilla)
coord
coord <- as.data.frame(coord)
str(coord)
seq(from = 1, to = N*N)
human <- seq(from = 1, to = N*N)
coord <- cbind(human, coord)
head(coord)
colnames(coord) <- c("human", "x", "y")
head(coord)
C <- genStatialDistribution(df = coord, alpha = 1.5)
source("get_powerLaw_prob_function.R")
source("genSpatialDistribution_function.R")
C <- genStatialDistribution(df = coord, alpha = 1.5)
distances <- dist(coord[, c(2,3)] )
head(distances)
coord
coord[, c(2,3)]
distances <- as.matrix(distances)
head(distances)
distance[1,34]
distances[1,34]
rm(list = ls())
library(ggplot2)
library(gdata)
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
source("genBA_SpatialNet_function.R")
# # # # # Create the grille
N = 10 #total number of nodes (humanoids) of the grid-net
grilla <- make_lattice(length = N, dim = 2)
V(grilla)$name <- seq(from =1, to=N*N)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
# 1. get the coordinates from the lattice: coor <- layout_on_grid(grilla)
coord <- layout_on_grid(grilla)
coord <- as.data.frame(coord)
human <- seq(from = 1, to = N*N)
coord <- cbind(human, coord)
colnames(coord) <- c("human", "x", "y")
# 2. get the spatial distribution
source("get_powerLaw_prob_function.R")
source("genSpatialDistribution_function.R")
C <- genStatialDistribution(df = coord, alpha = 1.5) # constante
C
distances <- dist(coord[, c(2,3)] )
distances <- as.matrix(distances)
small_world_spatial_reconnect <- function(g, C, distances, vtx, ord = 1) {
# # # # # Get all neighborhoods of a node in a vector
# Ojo que el primer valor es el mismo nodo i.
if (ord == 2) {
ady1 <- as.numeric(unlist(ego(grilla, order = 1, vtx)))
ady2 <- as.numeric(unlist(ego(grilla, order = 2, vtx)))
ady <- c(ady1[1], setdiff(ady2, ady1))
} else {
ady <- as.numeric(unlist(ego(grilla, order = ord, vtx)))
}
# ady <- ady[-1]
#adjacent_vertices(grilla, 12 )
# # # # # Get all neighborhoods of a node in a vector
# select the k nodes to be sampled except ady
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
# start
for (i in 1:num) {
j <- i + 1
u <- runif(1)
# calculo de p segun la distancia
distt <- distances[ady[1], knodes[i]]
p <- get_powerLaw_prob(C = C, alpha = alpha, d = distt)
if ( u <= p) {
# add the edge
g <- add_edges(g, c(ady[1], knodes[i] ) )
# remove the old edge
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
#E(grilla)[ei]
g <- delete_edges(g, ei)
}
}
return(g)
}
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_spatial_reconnect(g = grilla, C=C, distances=distances, vtx = i, ord = 1)
}
small_world_spatial_reconnect <- function(g, C, distances, vtx, alpha = 1.5, ord = 1) {
# # # # # Get all neighborhoods of a node in a vector
# Ojo que el primer valor es el mismo nodo i.
if (ord == 2) {
ady1 <- as.numeric(unlist(ego(grilla, order = 1, vtx)))
ady2 <- as.numeric(unlist(ego(grilla, order = 2, vtx)))
ady <- c(ady1[1], setdiff(ady2, ady1))
} else {
ady <- as.numeric(unlist(ego(grilla, order = ord, vtx)))
}
# ady <- ady[-1]
#adjacent_vertices(grilla, 12 )
# # # # # Get all neighborhoods of a node in a vector
# select the k nodes to be sampled except ady
num = length(ady)-1
knodes <- sample(setdiff(V(g)$name, ady), num, replace=F)
# start
for (i in 1:num) {
j <- i + 1
u <- runif(1)
# calculo de p segun la distancia
distt <- distances[ady[1], knodes[i]]
p <- get_powerLaw_prob(C = C, alpha = alpha, d = distt)
if ( u <= p) {
# add the edge
g <- add_edges(g, c(ady[1], knodes[i] ) )
# remove the old edge
ei <- get.edge.ids(g, c(ady[1], ady[j]) )
#E(grilla)[ei]
g <- delete_edges(g, ei)
}
}
return(g)
}
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_spatial_reconnect(g = grilla, C=C, distances=distances, vtx = i, alpha = 1.5, ord = 1)
}
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
rm(list = ls())
library(ggplot2)
library(gdata)
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
source("genBA_SpatialNet_function.R")
source("get_powerLaw_prob_function.R")
source("genSpatialDistribution_function.R")
source("small_world_spatial_reconnect_function.R")
# # # # # Create the grille
N = 10 #total number of nodes (humanoids) of the grid-net
grilla <- make_lattice(length = N, dim = 2)
V(grilla)$name <- seq(from =1, to=N*N)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
hist(degree(grilla))
# dic 27, 2019
# Now we try with the spatial small world network
# 1. get the coordinates from the lattice: coor <- layout_on_grid(grilla)
coord <- layout_on_grid(grilla)
coord <- as.data.frame(coord)
human <- seq(from = 1, to = N*N)
coord <- cbind(human, coord)
colnames(coord) <- c("human", "x", "y")
# 2. get the spatial distribution
C <- genStatialDistribution(df = coord, alpha = 1.5) # constante
# 3. get the distances among nodes in the lattice
distances <- dist(coord[, c(2,3)] )
distances <- as.matrix(distances)
# The magic!!
# # # # # Select other node k, and reconnect with node i with probability p
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_spatial_reconnect(g = grilla, C=C, distances=distances, vtx = i, alpha = 1.5, ord = 1)
}
# # # # # Select other node k, and reconnect with node i with probability p
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
# # # # # Create the grille
N = 50 #total number of nodes (humanoids) of the grid-net
grilla <- make_lattice(length = N, dim = 2)
V(grilla)$name <- seq(from =1, to=N*N)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Grille", cex.main=0.5, col.main="black")
hist(degree(grilla))
# dic 27, 2019
# Now we try with the spatial small world network
# 1. get the coordinates from the lattice: coor <- layout_on_grid(grilla)
coord <- layout_on_grid(grilla)
coord <- as.data.frame(coord)
human <- seq(from = 1, to = N*N)
coord <- cbind(human, coord)
colnames(coord) <- c("human", "x", "y")
# 2. get the spatial distribution
C <- genStatialDistribution(df = coord, alpha = 1.5) # constante
# 3. get the distances among nodes in the lattice
distances <- dist(coord[, c(2,3)] )
distances <- as.matrix(distances)
# The magic!!
# # # # # Select other node k, and reconnect with node i with probability p
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_spatial_reconnect(g = grilla, C=C, distances=distances, vtx = i, alpha = 1.5, ord = 1)
}
# # # # # Select other node k, and reconnect with node i with probability p
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 3)
title("Grille", cex.main=0.5, col.main="black")
plot(grilla, layout=layout_on_grid,
edge.arrow.size =.7,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 3)
title("Grille", cex.main=0.5, col.main="black")
plot(grilla, layout=layout_on_grid,
edge.arrow.size =1,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 3)
title("Grille", cex.main=0.5, col.main="black")
plot(grilla, layout=layout_on_grid,
edge.arrow.size =1.5,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 1)
title("Grille", cex.main=0.5, col.main="black")
# # # # # Create the grille
N = 50 #total number of nodes (humanoids) of the grid-net
grilla <- make_lattice(length = N, dim = 2)
V(grilla)$name <- seq(from =1, to=N*N)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(grilla, layout=layout_on_grid,
edge.arrow.size =1.5,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 1)
title("Grille", cex.main=0.5, col.main="black")
hist(degree(grilla))
# dic 27, 2019
# Now we try with the spatial small world network
# 1. get the coordinates from the lattice: coor <- layout_on_grid(grilla)
coord <- layout_on_grid(grilla)
coord <- as.data.frame(coord)
human <- seq(from = 1, to = N*N)
coord <- cbind(human, coord)
colnames(coord) <- c("human", "x", "y")
# 2. get the spatial distribution
C <- genStatialDistribution(df = coord, alpha = 1.1) # constante
# 3. get the distances among nodes in the lattice
distances <- dist(coord[, c(2,3)] )
distances <- as.matrix(distances)
# The magic!!
# # # # # Select other node k, and reconnect with node i with probability p
nn <- N*N
for (i in seq_along(1:nn)) {
grilla <- small_world_spatial_reconnect(g = grilla, C=C, distances=distances, vtx = i, alpha = 1.1, ord = 1)
}
# # # # # Select other node k, and reconnect with node i with probability p
plot(grilla, layout=layout_on_grid,
edge.arrow.size =1.5,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(grilla)$name,
vertex.label.color = "black",
vertex.label.cex=.2,
vertex.size = 1)
title("Grille", cex.main=0.5, col.main="black")
q()
