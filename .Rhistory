node_sample <- sample(nodes_to_sample, 1)
p <- the_probabilities[node_sample]
v <- runif(1)
if ( p > v ) {
conection[node_sample] <- 1
dg <- dg + 1
sampled_nodes <- c(sampled_nodes, node_sample) # lista de nodos sampleados
nodes_to_sample <- nodes_to_sample[-node_sample] # ya no se puede samplear nuevamente este nodo
}
}
return(conection)
}
genBANet <- function(m0, m, N) {
library(igraph)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
for (j in 1:N) {
dgg <- colSums(A)
sum_degree <- sum(dgg)
the_probabilities <- dgg/sum_degree
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
fin <- j + m0
colnames(A) <- rownames(A) <- 1:fin
}
gg <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE, add.colnames = NULL, add.rownames = NA)
return(gg)
}
g <- genBANet (m0 = 3, m = 2, N = 200)
genBANet <- function(m0, m, N) {
library(igraph)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
for (j in 1:N) {
dgg <- colSums(A)
sum_degree <- sum(dgg)
the_probabilities <- dgg/sum_degree
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
fin <- j + m0
colnames(A) <- rownames(A) <- 1:fin
}
gg <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE, add.colnames = NULL, add.rownames = NA)
return(gg)
}
g <- genBANet (m0 = 3, m = 2, N = 200)
hist(degree(g))
plot(g)
q()
source("lattice_creation_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
df <- lattice_creation(m = 100, number_of_humans = N-m0) #aqui m es largo de la grilla.
df
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# 04, dic. 19
library(igraph)
source("lattice_creation_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
df <- lattice_creation(m = 100, number_of_humans = N-m0) #aqui m es largo de la grilla.
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
A
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
help(ifelse)
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degre^2 - min_degre^2 = 0, 1, max_degre^2 - min_degre^2)
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
alpha = 1.1
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
C <- 2*(1-alpha)/(c1*c2)
dgg <- colSums(A) # degree de los nodos
head(df)
j= 4
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
disatances <- distances[,ncol(distances)]
distances <- distances[,ncol(distances)]
distances
View(df)
length(distances)
distances <- distances[-length(distances)]
distances
dgg
distances_ <- distances^(1-alpha)
distances_
C*dgg*distances_
the_probabilities <- C*dgg*distances_
random_node_select <- function(A, the_probabilities) {
dg = 0
conection <- numeric(length = ncol(A) ) # salida importante
sampled_nodes <- vector()
nodes_to_sample <- as.numeric(colnames(A))
while (dg < m) {
node_sample <- sample(nodes_to_sample, 1)
p <- the_probabilities[node_sample]
v <- runif(1)
if ( p > v ) {
conection[node_sample] <- 1
dg <- dg + 1
sampled_nodes <- c(sampled_nodes, node_sample) # lista de nodos sampleados
nodes_to_sample <- nodes_to_sample[-node_sample] # ya no se puede samplear nuevamente este nodo
}
}
return(conection)
}
conection <- random_node_select(A, the_probabilities, m = m)
m
random_node_select <- function(A, the_probabilities, m) {
dg = 0
conection <- numeric(length = ncol(A) ) # salida importante
sampled_nodes <- vector()
nodes_to_sample <- as.numeric(colnames(A))
while (dg < m) {
node_sample <- sample(nodes_to_sample, 1)
p <- the_probabilities[node_sample]
v <- runif(1)
if ( p > v ) {
conection[node_sample] <- 1
dg <- dg + 1
sampled_nodes <- c(sampled_nodes, node_sample) # lista de nodos sampleados
nodes_to_sample <- nodes_to_sample[-node_sample] # ya no se puede samplear nuevamente este nodo
}
}
return(conection)
}
source("genBANet_function.R")
conection <- random_node_select(A, the_probabilities, m = m)
conection
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
fin <- j + m0
colnames(A) <- rownames(A) <- 1:fin
A
j
m0
colnames(A) <- rownames(A) <- 1:j
A
#esto se repite N veces de aqui en adelante:
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
c2
dgg
C <- 2*(1-alpha)/(c1*c2)
C
A
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances
j= 5
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
the_probabilities
conection <- random_node_select(A, the_probabilities, m = m)
conection
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
A
m0+1:N
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 10 #total number of nodes (iterations) of the net
alpha = 1.1
df <- lattice_creation(m = 100, number_of_humans = N) #aqui se incluyen los nodos iniciales de m0 (los primero m0)
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
plot(g)
A
for (j in m0+1:N) {
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
# calculo de la constante de la integral
C <- 2*(1-alpha)/(c1*c2)
# calculo de las probabilidades de conecciones
# para esto: primero elegir el nodo (no en el set de m0)
# segundo calcular la distancia entre ese nodo y todos los demas nodos en A.
#j va desde m0+1 hasta N
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
}
j
N
m0+1:N
help("sequential_pal")
help("seq")
seq(fron = m0+1, to = N, by=1)
seq(from = m0+1, to = N, by=1)
df <- lattice_creation(m = 100, number_of_humans = N) #aqui se incluyen los nodos iniciales de m0 (los primero m0)
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
for (j in seq(from = m0+1, to = N, by=1)) {
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
# calculo de la constante de la integral
C <- 2*(1-alpha)/(c1*c2)
# calculo de las probabilidades de conecciones
# para esto: primero elegir el nodo (no en el set de m0)
# segundo calcular la distancia entre ese nodo y todos los demas nodos en A.
#j va desde m0+1 hasta N
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
}
j
conection
A
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# 04, dic. 19
rm(list = ls())
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 50 #total number of nodes (iterations) of the net
alpha = 1.1
df <- lattice_creation(m = 100, number_of_humans = N) #aqui se incluyen los nodos iniciales de m0 (los primero m0)
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
A
#esto se repite N veces de aqui en adelante:
for (j in seq(from = m0+1, to = N, by=1)) {
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
# calculo de la constante de la integral
C <- 2*(1-alpha)/(c1*c2)
# calculo de las probabilidades de conecciones
# para esto: primero elegir el nodo (no en el set de m0)
# segundo calcular la distancia entre ese nodo y todos los demas nodos en A.
#j va desde m0+1 hasta N
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
}
A
hist(degree(g_spatial))
g_spatial <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE, add.colnames = NULL, add.rownames = NA)
hist(degree(g_spatial))
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(g_spatial,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(mst_g)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Spatial BA Net", cex.main=0.5, col.main="black")
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# 04, dic. 19
rm(list = ls())
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 100 #total number of nodes (iterations) of the net
alpha = 1.1
df <- lattice_creation(m = 100, number_of_humans = N) #aqui se incluyen los nodos iniciales de m0 (los primero m0)
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
#esto se repite N veces de aqui en adelante:
for (j in seq(from = m0+1, to = N, by=1)) {
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
# calculo de la constante de la integral
C <- 2*(1-alpha)/(c1*c2)
# calculo de las probabilidades de conecciones
# para esto: primero elegir el nodo (no en el set de m0)
# segundo calcular la distancia entre ese nodo y todos los demas nodos en A.
#j va desde m0+1 hasta N
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
}
# create the net from adjacency matrix A
g_spatial <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE, add.colnames = NULL, add.rownames = NA)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(g_spatial,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(mst_g)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Spatial BA Net", cex.main=0.5, col.main="black")
hist(degree(g_spatial))
# # # # # # # # # # # # # # # # # # # # # # # # # # #
# 04, dic. 19
rm(list = ls())
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
alpha = 1.1
df <- lattice_creation(m = 100, number_of_humans = N) #aqui se incluyen los nodos iniciales de m0 (los primero m0)
distances <- dist(df[, c(2,3)] )
max_distance <- max(distances)
min_distance <- min(distances)
c1 <- max_distance^(1-alpha) - min_distance^(1-alpha)
g <- make_full_graph(m0)
V(g)$name <- 1:m0
A <- as_adjacency_matrix(g, sparse = FALSE)
#esto se repite N veces de aqui en adelante:
for (j in seq(from = m0+1, to = N, by=1)) {
dgg <- colSums(A) # degree de los nodos
max_degree <- max(colSums(A))
min_degree <- min(colSums(A))
c2 <- ifelse(max_degree^2 - min_degree^2 == 0, 1, max_degree^2 - min_degree^2)
# calculo de la constante de la integral
C <- 2*(1-alpha)/(c1*c2)
# calculo de las probabilidades de conecciones
# para esto: primero elegir el nodo (no en el set de m0)
# segundo calcular la distancia entre ese nodo y todos los demas nodos en A.
#j va desde m0+1 hasta N
distances <- as.matrix(dist(df[c(1:j), c(2,3)]))
distances <- distances[,ncol(distances)]
distances <- distances[-length(distances)]
distances_ <- distances^(1-alpha)
the_probabilities <- C*dgg*distances_
# choose a node j from g at random
conection <- random_node_select(A, the_probabilities, m = m)
# ahora tengo que formar nueva matriz de adyacencia con los datos de conection
# el nuevo nodo "4" se coenctara a los nodos de conection que tengan valor 1.
A <- cbind(A, conection)
A <- rbind(A, c(conection, 0 ) )
colnames(A) <- rownames(A) <- 1:j
}
# create the net from adjacency matrix A
g_spatial <- graph_from_adjacency_matrix(A, mode = "undirected", diag = FALSE, add.colnames = NULL, add.rownames = NA)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(g_spatial,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(mst_g)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Spatial BA Net", cex.main=0.5, col.main="black")
hist(degree(g_spatial))
hist(degree(g_spatial))
rm(list = ls())
library(ggplot2)
library(gdata)
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
source("genBA_Spatial_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
alpha = 1.1
rm(list = ls())
library(ggplot2)
library(gdata)
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
source("genBA_SpatialNet_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
alpha = 1.1
g_spatial <- genBA_SpatialNet(m0 = 3, m=2, N=200, alpha=1.1)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(g_spatial,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(mst_g)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Spatial BA Net", cex.main=0.5, col.main="black")
rm(list = ls())
library(ggplot2)
library(gdata)
library(igraph)
source("lattice_creation_function.R")
source("genBANet_function.R")
source("genBA_SpatialNet_function.R")
#parameters
m0 = 3 #initial number of full connected nodes
m = 2 #number of connection desired for each ieration
N = 200 #total number of nodes (iterations) of the net
alpha = 1.1
g_spatial <- genBA_SpatialNet(m0 = 3, m=2, N=200, alpha=1.1, size_lattice=100)
par(mar = c(1.5, 1.5, 1.5, 1.5))
plot(g_spatial,
edge.arrow.size =.3,
edge.curved = 0,
vertex.color = "yellow",
vertex.frame.color="#555555",
#vertex.label = V(mst_g)$name,
vertex.label.color = "black",
vertex.label.cex=.6,
vertex.size = 7)
title("Spatial BA Net", cex.main=0.5, col.main="black")
q()
